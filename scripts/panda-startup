#!/usr/bin/env python3
import threading
import signal
import sys
import os
import tempfile
import systemd.daemon

from armer_panda.PandaConnector import PandaConnector
event = threading.Event()

signal.signal(signal.SIGINT, lambda *args: event.set())
signal.signal(signal.SIGTERM, lambda *args: event.set())


def main():
  robot_ip = '172.16.0.2'
  command = None

  if len(sys.argv) > 1:
    robot_ip = sys.argv[1]

  if len(sys.argv) > 2 and sys.argv[2] in ['--startup', '--shutdown']:
    command = sys.argv[2]

  # default username and password (backwards compatibility)
  username='franka'
  password='MjMsMTY0LDIzMSwxNjIsMTM4LDEyMCwxOTQsNTUsMTk2LDI5LDE5Myw5MCwxNzAsMTgsODIsMTEyLDE5NCw3MywxNjMsMTA0LDEsNTksMjAxLDk1LDI0OCwyMjAsMTcsMTgyLDQxLDI0MywzOSwxMTc='
  
  # optionally pull in username and password from environment variable
  if 'PANDA_USER' in os.environ:
    username = os.environ['PANDA_USER']
  if 'PANDA_PASSWORD' in os.environ:
    password = os.environ['PANDA_PASSWORD']

  panda = PandaConnector(robot_ip, username, password)
  
  if not panda.connect():
    print('Unable to connect to panda on address: {}'.format(robot_ip), file=sys.stderr)
    sys.exit(1)

  # oneshot for startup
  if command == '--startup':
    # get control token
    if panda.control_token_req and not panda.acquire_control_token():
        print("Unable to get control token from panda")
        sys.exit(2)

    panda.open_brakes()
    panda.home_gripper()
    
    if panda.control_token_req:
      # enable fci
      panda.enable_fci()

      # since we are running as a oneshot and we must leave the control token active while FCI is running, we store the 
      # control token in a tmp file so that we can retreive it and release it when running --shutdown.
      try:
        tmp_file = open(tempfile.gettempdir()+'/panda_token','w')
        tmp_file.write(panda.control_token + '\n')
        tmp_file.write(str(panda.control_token_id))
        tmp_file.close()
      except Exception as e:
        print('Unable to store control token (' + str(e) + '). Shutdown will required forced control takeover')
      else:
        print('Control Token \'{}\' has been written to /tmp/panda_token'.format(panda.control_token))

    print("Startup complete")
    systemd.daemon.notify('READY=1')

  # oneshot for shutdown
  elif command == '--shutdown':
    if panda.control_token_req:
      # since shutdown is being run as a oneshot, we must check to see if the control token was stored on the system
      # from a previous startup oneshot. If so, we read it in and attempt to use it. If the stored token is invalid (or
      # we fail to read the file correctly for any reason), then we will instead attempt to acquire a new control token,
      # which may require the user to hit the manual override.
      try:
        tmp_file = open('/tmp/panda_token', 'r')
        control_strs = tmp_file.read().splitlines()
        panda.control_token = control_strs[0]
        panda.control_token_id = int(control_strs[1])
        tmp_file.close()
        # delete the temp file once we've taken control as we will release it after we are finished
        os.remove('/tmp/panda_token')
      except Exception as e:
        print('Unable to get an existing control token, will attempt to forcibly acquire control')
    
      if not panda.is_control_token_active() and not panda.acquire_control_token():
        print("Unable to get control token from panda")
        sys.exit(2)

    panda.close_brakes()
    
    if panda.control_token_req:
      panda.disable_fci()
      panda.release_control_token()
    
    print('shutdown complete')

  else:
    if panda.control_token_req and not panda.acquire_control_token():
        print("Unable to get control token from panda")
        sys.exit(2)

    panda.open_brakes()
    panda.home_gripper()
    
    if panda.control_token_req:
      panda.enable_fci()

    systemd.daemon.notify('READY=1')   
    
    # wait for shutdown signal
    event.wait() 
    
    panda.close_brakes()

    if panda.control_token_req:
      panda.disable_fci()
      panda.release_control_token()

    print('Done')

if __name__ == '__main__':
    main()
